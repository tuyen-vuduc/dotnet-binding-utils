#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.9 (swiftlang-5.9.0.128.108 clang-1500.0.40.1)
#ifndef STRIPE_SWIFT_H
#define STRIPE_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreFoundation;
@import Foundation;
@import ObjectiveC;
@import PassKit;
@import StripeApplePay;
@import StripeCore;
@import StripePayments;
@import StripePaymentsUI;
@import UIKit;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="Stripe",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)




@class STPPaymentConfiguration;

@interface STPAPIClient (SWIFT_EXTENSION(Stripe))
/// The client’s configuration.
/// Defaults to <code>STPPaymentConfiguration.shared</code>.
@property (nonatomic, strong) STPPaymentConfiguration * _Nonnull configuration;
@end

@class STPTheme;
@class NSString;
@class NSBundle;
@class NSCoder;

/// This is the base class for all Stripe view controllers. It is intended for use
/// only by Stripe classes, you should not subclass it yourself in your app.
/// It theming, back/cancel button management, and other shared logic for
/// Stripe view controllers.
SWIFT_CLASS("_TtC6Stripe21STPCoreViewController")
@interface STPCoreViewController : UIViewController
/// A convenience initializer; equivalent to calling <code>init(theme: STPTheme.defaultTheme)</code>.
- (nonnull instancetype)init;
/// Initializes a new view controller with the specified theme
/// \param theme The theme to use to inform the view controller’s visual appearance. - seealso: STPTheme
///
- (nonnull instancetype)initWithTheme:(STPTheme * _Nullable)theme OBJC_DESIGNATED_INITIALIZER;
/// Passes through to the default UIViewController behavior for this initializer,
/// and then also sets the default theme as in <code>init</code>
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
/// Passes through to the default UIViewController behavior for this initializer,
/// and then also sets the default theme as in <code>init</code>
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// :nodoc:
- (void)viewDidLoad;
/// :nodoc:
- (void)viewWillAppear:(BOOL)animated;
/// :nodoc:
- (void)viewWillDisappear:(BOOL)animated;
/// :nodoc:
@property (nonatomic, readonly) UIStatusBarStyle preferredStatusBarStyle;
@end

@class UIScrollView;

/// This is the base class for all Stripe scroll view controllers. It is intended
/// for use only by Stripe classes, you should not subclass it yourself in your app.
SWIFT_CLASS("_TtC6Stripe27STPCoreScrollViewController")
@interface STPCoreScrollViewController : STPCoreViewController
/// This returns the scroll view being managed by the view controller
@property (nonatomic, strong) UIScrollView * _Nonnull scrollView;
/// :nodoc:
- (void)viewDidLoad;
/// :nodoc:
- (void)viewDidLayoutSubviews;
- (nonnull instancetype)initWithTheme:(STPTheme * _Nullable)theme OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class UITableView;

/// This is the base class for all Stripe scroll view controllers. It is intended
/// for use only by Stripe classes, you should not subclass it yourself in your app.
/// It inherits from STPCoreScrollViewController and changes the type of the
/// created scroll view to UITableView, as well as other shared table view logic.
SWIFT_CLASS("_TtC6Stripe26STPCoreTableViewController")
@interface STPCoreTableViewController : STPCoreScrollViewController
/// This points to the same object as <code>STPCoreScrollViewController</code>’s <code>scrollView</code>
/// property but with the type cast to <code>UITableView</code>
@property (nonatomic, readonly, strong) UITableView * _Nullable tableView;
/// :nodoc:
- (void)viewWillAppear:(BOOL)animated;
/// :nodoc:
- (CGFloat)tableView:(UITableView * _Nonnull)tableView heightForHeaderInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithTheme:(STPTheme * _Nullable)theme OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@protocol STPAddCardViewControllerDelegate;
@class STPUserInformation;
@class UIView;
@class NSIndexPath;
@class STPPaymentCardTextField;
@class UITableViewCell;
@protocol UIViewControllerTransitionCoordinator;

/// This view controller contains a credit card entry form that the user can fill out. On submission, it will use the Stripe API to convert the user’s card details to a Stripe token. It renders a right bar button item that submits the form, so it must be shown inside a <code>UINavigationController</code>.
SWIFT_CLASS("_TtC6Stripe24STPAddCardViewController")
@interface STPAddCardViewController : STPCoreTableViewController <STPPaymentCardTextFieldDelegate, UITableViewDataSource, UITableViewDelegate>
/// A convenience initializer; equivalent to calling <code>init(configuration: STPPaymentConfiguration.shared, theme: STPTheme.defaultTheme)</code>.
- (nonnull instancetype)init;
/// Initializes a new <code>STPAddCardViewController</code> with the provided configuration and theme. Don’t forget to set the <code>delegate</code> property after initialization.
/// \param configuration The configuration to use (this determines the Stripe publishable key to use, the required billing address fields, whether or not to use SMS autofill, etc). - seealso: STPPaymentConfiguration
///
/// \param theme The theme to use to inform the view controller’s visual appearance. - seealso: STPTheme
///
- (nonnull instancetype)initWithConfiguration:(STPPaymentConfiguration * _Nonnull)configuration theme:(STPTheme * _Nonnull)theme OBJC_DESIGNATED_INITIALIZER;
/// The view controller’s delegate. This must be set before showing the view controller in order for it to work properly. - seealso: STPAddCardViewControllerDelegate
@property (nonatomic, weak) id <STPAddCardViewControllerDelegate> _Nullable delegate;
/// You can set this property to pre-fill any information you’ve already collected from your user. - seealso: STPUserInformation.h
@property (nonatomic, strong) STPUserInformation * _Nullable prefilledInformation;
/// Provide this view controller with a footer view.
/// When the footer view needs to be resized, it will be sent a
/// <code>sizeThatFits:</code> call. The view should respond correctly to this method in order
/// to be sized and positioned properly.
@property (nonatomic, strong) UIView * _Nullable customFooterView;
/// Use init: or initWithConfiguration:theme:
- (nonnull instancetype)initWithTheme:(STPTheme * _Nullable)theme SWIFT_UNAVAILABLE;
/// Use init: or initWithConfiguration:theme:
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
/// Use init: or initWithConfiguration:theme:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// :nodoc:
- (CGFloat)tableView:(UITableView * _Nonnull)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (void)viewDidLayoutSubviews;
/// :nodoc:
- (void)updateAppearance;
/// :nodoc:
- (void)viewDidAppear:(BOOL)animated;
/// :nodoc:
- (void)handleCancelTapped:(id _Nullable)sender;
- (void)paymentCardTextFieldDidChange:(STPPaymentCardTextField * _Nonnull)textField;
- (void)paymentCardTextFieldWillEndEditingForReturn:(STPPaymentCardTextField * _Nonnull)textField;
- (void)paymentCardTextFieldDidBeginEditingCVC:(STPPaymentCardTextField * _Nonnull)textField;
- (void)paymentCardTextFieldDidEndEditingCVC:(STPPaymentCardTextField * _Nonnull)textField;
- (void)paymentCardTextFieldDidBeginEditing:(STPPaymentCardTextField * _Nonnull)textField;
/// :nodoc:
- (NSInteger)numberOfSectionsInTableView:(UITableView * _Nonnull)tableView SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (NSInteger)tableView:(UITableView * _Nonnull)tableView numberOfRowsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (UITableViewCell * _Nonnull)tableView:(UITableView * _Nonnull)tableView cellForRowAtIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (void)tableView:(UITableView * _Nonnull)tableView willDisplayCell:(UITableViewCell * _Nonnull)cell forRowAtIndexPath:(NSIndexPath * _Nonnull)indexPath;
/// :nodoc:
- (CGFloat)tableView:(UITableView * _Nonnull)tableView heightForFooterInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (CGFloat)tableView:(UITableView * _Nonnull)tableView heightForHeaderInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (UIView * _Nullable)tableView:(UITableView * _Nonnull)tableView viewForHeaderInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (UIView * _Nullable)tableView:(UITableView * _Nonnull)tableView viewForFooterInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
@end


@class STPPaymentMethod;
@class STPToken;
@class STPSource;

/// An <code>STPAddCardViewControllerDelegate</code> is notified when an <code>STPAddCardViewController</code>
/// successfully creates a card token or is cancelled. It has internal error-handling
/// logic, so there’s no error case to deal with.
SWIFT_PROTOCOL("_TtP6Stripe32STPAddCardViewControllerDelegate_")
@protocol STPAddCardViewControllerDelegate <NSObject>
/// Called when the user cancels adding a card. You should dismiss (or pop) the
/// view controller at this point.
/// \param addCardViewController the view controller that has been cancelled
///
- (void)addCardViewControllerDidCancel:(STPAddCardViewController * _Nonnull)addCardViewController;
/// This is called when the user successfully adds a card and Stripe returns a
/// Payment Method.
/// You should send the PaymentMethod to your backend to store it on a customer, and then
/// call the provided <code>completion</code> block when that call is finished. If an error
/// occurs while talking to your backend, call <code>completion(error)</code>, otherwise,
/// dismiss (or pop) the view controller.
/// \param addCardViewController the view controller that successfully created a token
///
/// \param paymentMethod the Payment Method that was created. - seealso: STPPaymentMethod
///
/// \param completion call this callback when you’re done sending the token to your backend
///
- (void)addCardViewController:(STPAddCardViewController * _Nonnull)addCardViewController didCreatePaymentMethod:(STPPaymentMethod * _Nonnull)paymentMethod completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
@optional
/// This method is deprecated as of v16.0.0 (https://github.com/stripe/stripe-ios/blob/master/MIGRATING.md#migrating-from-versions–1600).
/// To use this class, migrate your integration from Charges to PaymentIntents. See https://stripe.com/docs/payments/payment-intents/migration/charges#read
- (void)addCardViewController:(STPAddCardViewController * _Nonnull)addCardViewController didCreateToken:(STPToken * _Nonnull)token completion:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nullable))completion SWIFT_DEPRECATED_MSG("Use addCardViewController(_:didCreatePaymentMethod:completion:) instead and migrate your integration to PaymentIntents. See https://stripe.com/docs/payments/payment-intents/migration/charges#read", "addCardViewController:didCreatePaymentMethod:completion:");
/// This method is deprecated as of v16.0.0 (https://github.com/stripe/stripe-ios/blob/master/MIGRATING.md#migrating-from-versions–1600).
/// To use this class, migrate your integration from Charges to PaymentIntents. See https://stripe.com/docs/payments/payment-intents/migration/charges#read
- (void)addCardViewController:(STPAddCardViewController * _Nonnull)addCardViewController didCreateSource:(STPSource * _Nonnull)source completion:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nullable))completion SWIFT_DEPRECATED_MSG("Use addCardViewController(_:didCreatePaymentMethod:completion:) instead and migrate your integration to PaymentIntents. See https://stripe.com/docs/payments/payment-intents/migration/charges#read", "addCardViewController:didCreatePaymentMethod:completion:");
@end

enum STPBillingAddressFields : NSUInteger;
@class STPContactField;

@interface STPAddress (SWIFT_EXTENSION(Stripe))
/// Checks if this STPAddress has the level of valid address information
/// required by the passed in setting.
/// \param requiredFields The required level of billing address information to
/// check against.
///
///
/// returns:
/// YES if this address contains at least the necessary information,
/// NO otherwise.
- (BOOL)containsRequiredFields:(enum STPBillingAddressFields)requiredFields SWIFT_WARN_UNUSED_RESULT;
/// Checks if this STPAddress has any content (possibly invalid) in any of the
/// desired billing address fields.
/// Where <code>containsRequiredFields:</code> validates that this STPAddress contains valid data in
/// all of the required fields, this method checks for the existence of <em>any</em> data.
/// For example, if <code>desiredFields</code> is <code>STPBillingAddressFieldsZip</code>, this will check
/// if the postalCode is empty.
/// Note: When <code>desiredFields == STPBillingAddressFieldsNone</code>, this method always returns
/// NO.
/// @parameter desiredFields The billing address information the caller is interested in.
///
/// returns:
/// YES if there is any data in this STPAddress that’s relevant for those fields.
- (BOOL)containsContentForBillingAddressFields:(enum STPBillingAddressFields)desiredFields SWIFT_WARN_UNUSED_RESULT;
/// Checks if this STPAddress has the level of valid address information
/// required by the passed in setting.
/// Note: When <code>requiredFields == nil</code>, this method always returns
/// YES.
/// \param requiredFields The required shipping address information to check against.
///
///
/// returns:
/// YES if this address contains at least the necessary information,
/// NO otherwise.
- (BOOL)containsRequiredShippingAddressFields:(NSSet<STPContactField *> * _Nullable)requiredFields SWIFT_WARN_UNUSED_RESULT;
/// Checks if this STPAddress has any content (possibly invalid) in any of the
/// desired shipping address fields.
/// Where <code>containsRequiredShippingAddressFields:</code> validates that this STPAddress
/// contains valid data in all of the required fields, this method checks for the
/// existence of <em>any</em> data.
/// Note: When <code>desiredFields == nil</code>, this method always returns
/// NO.
/// @parameter desiredFields The shipping address information the caller is interested in.
///
/// returns:
/// YES if there is any data in this STPAddress that’s relevant for those fields.
- (BOOL)containsContentForShippingAddressFields:(NSSet<STPContactField *> * _Nullable)desiredFields SWIFT_WARN_UNUSED_RESULT;
/// Converts an STPBillingAddressFields enum value into the closest equivalent
/// representation of PKContactField options
/// \param billingAddressFields Stripe billing address fields enum value to convert.
///
///
/// returns:
/// The closest representation of the billing address requirement as
/// a PKContactField value.
+ (NSSet<PKContactField> * _Nonnull)applePayContactFieldsFromBillingAddressFields:(enum STPBillingAddressFields)billingAddressFields SWIFT_WARN_UNUSED_RESULT;
/// Converts a set of STPContactField values into the closest equivalent
/// representation of PKContactField options
/// \param contactFields Stripe contact fields values to convert.
///
///
/// returns:
/// The closest representation of the contact fields as
/// a PKContactField value.
+ (NSSet<PKContactField> * _Nullable)pkContactFieldsFromStripeContactFields:(NSSet<STPContactField *> * _Nullable)contactFields SWIFT_WARN_UNUSED_RESULT;
@end

@class STPApplePayContext;
@class PKPayment;

/// Implement the required methods of this delegate to supply a PaymentIntent to STPApplePayContext and be notified of the completion of the Apple Pay payment.
/// You may also implement the optional delegate methods to handle shipping methods and shipping address changes e.g. to verify you can ship to the address, or update the payment amount.
SWIFT_PROTOCOL("_TtP6Stripe26STPApplePayContextDelegate_")
@protocol STPApplePayContextDelegate <_stpinternal_STPApplePayContextDelegateBase>
/// Called after the customer has authorized Apple Pay.  Implement this method to call the completion block with the client secret of a PaymentIntent or SetupIntent.
/// \param paymentMethod The PaymentMethod that represents the customer’s Apple Pay payment method.
/// If you create the PaymentIntent with confirmation_method=manual, pass <code>paymentMethod.stripeId</code> as the payment_method and confirm=true. Otherwise, you can ignore this parameter.
///
/// \param paymentInformation The underlying PKPayment created by Apple Pay.
/// If you create the PaymentIntent with confirmation_method=manual, you can collect shipping information using its <code>shippingContact</code> and <code>shippingMethod</code> properties.
///
/// \param completion Call this with the PaymentIntent or SetupIntent client secret, or the error that occurred creating the PaymentIntent or SetupIntent.
///
- (void)applePayContext:(STPApplePayContext * _Nonnull)context didCreatePaymentMethod:(STPPaymentMethod * _Nonnull)paymentMethod paymentInformation:(PKPayment * _Nonnull)paymentInformation completion:(void (^ _Nonnull)(NSString * _Nullable, NSError * _Nullable))completion;
/// Called after the Apple Pay sheet is dismissed with the result of the payment.
/// Your implementation could stop a spinner and display a receipt view or error to the customer, for example.
/// \param status The status of the payment
///
/// \param error The error that occurred, if any.
///
- (void)applePayContext:(STPApplePayContext * _Nonnull)context didCompleteWithStatus:(enum STPPaymentStatus)status error:(NSError * _Nullable)error;
@end

@class UIImage;

/// This protocol represents a payment method that a user can select and use to
/// pay.
/// The classes that conform to it and are supported by the UI:
/// <ul>
///   <li>
///     <code>STPApplePay</code>, which represents that the user wants to pay with
///     Apple Pay
///   </li>
///   <li>
///     <code>STPPaymentMethod</code>.  Only <code>STPPaymentMethod.type == STPPaymentMethodTypeCard</code> and
///     <code>STPPaymentMethod.type == STPPaymentMethodTypeFPX</code> are supported by <code>STPPaymentContext</code>
///     and <code>STPPaymentOptionsViewController</code>
///   </li>
///   <li>
///     <code>STPPaymentMethodParams</code>. This should be used with non-reusable payment method, such
///     as FPX and iDEAL. Instead of reaching out to Stripe to create a PaymentMethod, you can
///     pass an STPPaymentMethodParams directly to Stripe when confirming a PaymentIntent.
///     @note card-based Sources, Cards, and FPX support this protocol for use
///     in a custom integration.
///   </li>
/// </ul>
SWIFT_PROTOCOL("_TtP6Stripe16STPPaymentOption_")
@protocol STPPaymentOption <NSObject>
/// A small (32 x 20 points) logo image representing the payment method. For
/// example, the Visa logo for a Visa card, or the Apple Pay logo.
@property (nonatomic, readonly, strong) UIImage * _Nonnull image;
/// A small (32 x 20 points) logo image representing the payment method that can be
/// used as template for tinted icons.
@property (nonatomic, readonly, strong) UIImage * _Nonnull templateImage;
/// A string describing the payment method, such as “Apple Pay” or “Visa 4242”.
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
/// Describes whether this payment option may be used multiple times. If it is not reusable,
/// the payment method must be discarded after use.
@property (nonatomic, readonly) BOOL isReusable;
@end


/// An empty class representing that the user wishes to pay via Apple Pay. This can
/// be checked on an <code>STPPaymentContext</code>, e.g:
/// \code
/// if paymentContext.selectedPaymentOption is STPApplePayPaymentOption {
/// // Don't ask the user for their card number; they want to pay with apple pay.
/// }
///
/// \endcode
SWIFT_CLASS("_TtC6Stripe24STPApplePayPaymentOption")
@interface STPApplePayPaymentOption : NSObject <STPPaymentOption>
@property (nonatomic, readonly, strong) UIImage * _Nonnull image;
@property (nonatomic, readonly, strong) UIImage * _Nonnull templateImage;
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
@property (nonatomic, readonly) BOOL isReusable;
/// :nodoc:
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
@property (nonatomic, readonly) NSUInteger hash;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class STPCustomer;

/// A “bridge” from our pre-built UI (<code>STPPaymentContext</code>, <code>STPPaymentOptionsViewController</code>)
/// to your backend to fetch Customer-related information needed to power those views.
/// Typically, you will not need to implement this protocol yourself. You
/// should instead use <code>STPCustomerContext</code>, which implements <STPBackendAPIAdapter>
/// and manages retrieving and updating a Stripe customer for you.
/// seealso:
/// STPCustomerContext.h
/// If you would prefer retrieving and updating your Stripe customer object via
/// your own backend instead of using <code>STPCustomerContext</code>, you should make your
/// application’s API client conform to this interface.
SWIFT_PROTOCOL("_TtP6Stripe20STPBackendAPIAdapter_")
@protocol STPBackendAPIAdapter <NSObject>
/// Retrieve the customer to be displayed inside a payment context.
/// If you are not using STPCustomerContext:
/// On your backend, retrieve the Stripe customer associated with your currently
/// logged-in user ( https://stripe.com/docs/api#retrieve_customer ), and return
/// the raw JSON response from the Stripe API. Back in your iOS app, after you’ve
/// called this API, deserialize your API response into an <code>STPCustomer</code> object
/// (you can use the <code>STPCustomerDeserializer</code> class to do this).
/// seealso:
/// STPCard
/// \param completion call this callback when you’re done fetching and parsing the above information from your backend. For example, <code>completion(customer, nil)</code> (if your call succeeds) or <code>completion(nil, error)</code> if an error is returned.
///
- (void)retrieveCustomer:(void (^ _Nullable)(STPCustomer * _Nullable, NSError * _Nullable))completion;
/// Retrieves a list of Payment Methods attached to a customer.
/// If you are implementing your own <STPBackendAPIAdapter>:
/// Call the list method ( https://stripe.com/docs/api/payment_methods/list )
/// with the Stripe customer. If this API call succeeds, call <code>completion(paymentMethods)</code>
/// with the list of PaymentMethods. Otherwise, call <code>completion(error)</code> with the error
/// that occurred.
/// \param completion Call this callback with the list of Payment Methods attached to the
/// customer.  For example, <code>completion(paymentMethods)</code> (if your call succeeds) or
/// <code>completion(error)</code> if an error is returned.
///
- (void)listPaymentMethodsForCustomerWithCompletion:(void (^ _Nullable)(NSArray<STPPaymentMethod *> * _Nullable, NSError * _Nullable))completion;
/// Adds a Payment Method to a customer.
/// If you are implementing your own <STPBackendAPIAdapter>:
/// On your backend, retrieve the Stripe customer associated with your logged-in user.
/// Then, call the Attach method on the Payment Method with that customer’s ID
/// ( https://stripe.com/docs/api/payment_methods/attach ). If this API call succeeds,
/// call <code>completion(nil)</code>. Otherwise, call <code>completion(error)</code> with the error that
/// occurred.
/// \param paymentMethod A valid Payment Method
///
/// \param completion Call this callback when you’re done adding the payment method
/// to the customer on your backend. For example, <code>completion(nil)</code> (if your call succeeds)
/// or <code>completion(error)</code> if an error is returned.
///
- (void)attachPaymentMethodToCustomer:(STPPaymentMethod * _Nonnull)paymentMethod completion:(void (^ _Nullable)(NSError * _Nullable))completion;
@optional
/// Deletes the given Payment Method from the customer.
/// If you are implementing your own <STPBackendAPIAdapter>:
/// Call the Detach method ( https://stripe.com/docs/api/payment_methods/detach )
/// on the Payment Method. If this API call succeeds, call <code>completion(nil)</code>.
/// Otherwise, call <code>completion(error)</code> with the error that occurred.
/// \param paymentMethod The Payment Method to delete from the customer
///
/// \param completion Call this callback when you’re done deleting the Payment Method
/// from the customer on your backend. For example, <code>completion(nil)</code> (if your call
/// succeeds) or <code>completion(error)</code> if an error is returned.
///
- (void)detachPaymentMethodFromCustomer:(STPPaymentMethod * _Nonnull)paymentMethod completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Sets the given shipping address on the customer.
/// If you are implementing your own <STPBackendAPIAdapter>:
/// On your backend, retrieve the Stripe customer associated with your logged-in user.
/// Then, call the Customer Update method ( https://stripe.com/docs/api#update_customer )
/// specifying shipping to be the given shipping address. If this API call succeeds,
/// call <code>completion(nil)</code>. Otherwise, call <code>completion(error)</code> with the error that occurred.
/// seealso:
/// https://stripe.com/docs/api#update_customer
/// \param shipping The shipping address to set on the customer
///
/// \param completion call this callback when you’re done updating the customer on
/// your backend. For example, <code>completion(nil)</code> (if your call succeeds) or
/// <code>completion(error)</code> if an error is returned.
///
- (void)updateCustomerWithShippingAddress:(STPAddress * _Nonnull)shipping completion:(void (^ _Nullable)(NSError * _Nullable))completion;
@end

/// The payment methods supported by STPBankSelectionViewController.
typedef SWIFT_ENUM(NSInteger, STPBankSelectionMethod, open) {
/// FPX (Malaysia)
  STPBankSelectionMethodFPX = 0,
/// An unknown payment method
  STPBankSelectionMethodUnknown = 1,
};

@protocol STPBankSelectionViewControllerDelegate;

/// This view controller displays a list of banks of the specified type, allowing the user to select one to pay from.
/// Once a bank is selected, it will return a PaymentMethodParams object, which you can use to confirm a PaymentIntent
/// or inspect to obtain details about the selected bank.
SWIFT_CLASS("_TtC6Stripe30STPBankSelectionViewController")
@interface STPBankSelectionViewController : STPCoreTableViewController <UITableViewDataSource, UITableViewDelegate>
/// A convenience initializer; equivalent to calling <code>init( bankMethod:bankMethod configuration:STPPaymentConfiguration.shared theme:STPTheme.defaultTheme</code>.
- (nonnull instancetype)initWithBankMethod:(enum STPBankSelectionMethod)bankMethod;
- (nonnull instancetype)initWithTheme:(STPTheme * _Nullable)theme;
/// Initializes a new <code>STPBankSelectionViewController</code> with the provided configuration and theme. Don’t forget to set the <code>delegate</code> property after initialization.
/// \param bankMethod The user will be presented with a list of banks for this payment method. STPBankSelectionMethodFPX is currently the only supported payment method.
///
/// \param configuration The configuration to use. This determines the Stripe publishable key to use when querying metadata about the banks. - seealso: STPPaymentConfiguration
///
/// \param theme The theme to use to inform the view controller’s visual appearance. - seealso: STPTheme
///
- (nonnull instancetype)initWithBankMethod:(enum STPBankSelectionMethod)bankMethod configuration:(STPPaymentConfiguration * _Nonnull)configuration theme:(STPTheme * _Nonnull)theme OBJC_DESIGNATED_INITIALIZER;
/// The view controller’s delegate. This must be set before showing the view controller in order for it to work properly. - seealso: STPBankSelectionViewControllerDelegate
@property (nonatomic, weak) id <STPBankSelectionViewControllerDelegate> _Nullable delegate;
/// :nodoc:
- (NSInteger)numberOfSectionsInTableView:(UITableView * _Nonnull)tableView SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (NSInteger)tableView:(UITableView * _Nonnull)tableView numberOfRowsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (UITableViewCell * _Nonnull)tableView:(UITableView * _Nonnull)tableView cellForRowAtIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (void)tableView:(UITableView * _Nonnull)tableView willDisplayCell:(UITableViewCell * _Nonnull)cell forRowAtIndexPath:(NSIndexPath * _Nonnull)indexPath;
/// :nodoc:
- (CGFloat)tableView:(UITableView * _Nonnull)tableView heightForFooterInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (BOOL)tableView:(UITableView * _Nonnull)tableView shouldHighlightRowAtIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (void)tableView:(UITableView * _Nonnull)tableView didSelectRowAtIndexPath:(NSIndexPath * _Nonnull)indexPath;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end


@class STPPaymentMethodParams;

/// An <code>STPBankSelectionViewControllerDelegate</code> is notified when a user selects a bank.
SWIFT_PROTOCOL("_TtP6Stripe38STPBankSelectionViewControllerDelegate_")
@protocol STPBankSelectionViewControllerDelegate <NSObject>
/// This is called when the user selects a bank.
/// You can use the returned PaymentMethodParams to confirm a PaymentIntent, or inspect
/// it to obtain details about the selected bank.
/// Once you’re done, you’ll want to dismiss (or pop) the view controller.
/// \param bankViewController the view controller that created the PaymentMethodParams
///
/// \param paymentMethodParams the PaymentMethodParams that was created. - seealso: STPPaymentMethodParams
///
- (void)bankSelectionViewController:(STPBankSelectionViewController * _Nonnull)bankViewController didCreatePaymentMethodParams:(STPPaymentMethodParams * _Nonnull)paymentMethodParams;
@end

/// What set of billing address information you need to collect from your user.
/// @note If the user is from a country that does not use zip/postal codes,
/// the user may not be asked for one regardless of this setting.
typedef SWIFT_ENUM(NSUInteger, STPBillingAddressFields, open) {
/// No billing address information
  STPBillingAddressFieldsNone = 0,
/// Just request the user’s billing postal code
  STPBillingAddressFieldsPostalCode = 1,
/// Request the user’s full billing address
  STPBillingAddressFieldsFull = 2,
/// Just request the user’s billing name
  STPBillingAddressFieldsName = 3,
/// Just request the user’s billing ZIP (synonym for STPBillingAddressFieldsZip)
  STPBillingAddressFieldsZip = 4,
};


@interface STPCard (SWIFT_EXTENSION(Stripe)) <STPPaymentOption>
@property (nonatomic, readonly, strong) UIImage * _Nonnull image;
@property (nonatomic, readonly, strong) UIImage * _Nonnull templateImage;
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
@property (nonatomic, readonly) BOOL isReusable;
@end




@protocol STPCustomerEphemeralKeyProvider;

/// An <code>STPCustomerContext</code> retrieves and updates a Stripe customer and their attached
/// payment methods using an ephemeral key, a short-lived API key scoped to a specific
/// customer object. If your current user logs out of your app and a new user logs in,
/// be sure to either create a new instance of <code>STPCustomerContext</code> or clear the current
/// instance’s cache. On your backend, be sure to create and return a
/// new ephemeral key for the Customer object associated with the new user.
SWIFT_CLASS("_TtC6Stripe18STPCustomerContext")
@interface STPCustomerContext : NSObject <STPBackendAPIAdapter>
/// Initializes a new <code>STPCustomerContext</code> with the specified key provider.
/// Upon initialization, a CustomerContext will fetch a new ephemeral key from
/// your backend and use it to prefetch the customer object specified in the key.
/// Subsequent customer and payment method retrievals (e.g. by <code>STPPaymentContext</code>)
/// will return the prefetched customer / attached payment methods immediately if
/// its age does not exceed 60 seconds.
/// \param keyProvider The key provider the customer context will use.
///
///
/// returns:
/// the newly-instantiated customer context.
- (nonnull instancetype)initWithKeyProvider:(id <STPCustomerEphemeralKeyProvider> _Nonnull)keyProvider;
/// Initializes a new <code>STPCustomerContext</code> with the specified key provider.
/// Upon initialization, a CustomerContext will fetch a new ephemeral key from
/// your backend and use it to prefetch the customer object specified in the key.
/// Subsequent customer and payment method retrievals (e.g. by <code>STPPaymentContext</code>)
/// will return the prefetched customer / attached payment methods immediately if
/// its age does not exceed 60 seconds.
/// \param keyProvider The key provider the customer context will use.
///
/// \param apiClient The API Client to use to make requests.
///
///
/// returns:
/// the newly-instantiated customer context.
- (nonnull instancetype)initWithKeyProvider:(id <STPCustomerEphemeralKeyProvider> _Nullable)keyProvider apiClient:(STPAPIClient * _Nonnull)apiClient;
/// <code>STPCustomerContext</code> will cache its customer object and associated payment methods
/// for up to 60 seconds. If your current user logs out of your app and a new user logs
/// in, be sure to either call this method or create a new instance of <code>STPCustomerContext</code>.
/// On your backend, be sure to create and return a new ephemeral key for the
/// customer object associated with the new user.
- (void)clearCache;
/// By default, <code>STPCustomerContext</code> will filter Apple Pay when it retrieves
/// Payment Methods. Apple Pay payment methods should generally not be re-used and
/// shouldn’t be offered to customers as a new payment method (Apple Pay payment
/// methods may only be re-used for subscriptions).
/// If you are using <code>STPCustomerContext</code> to back your own UI and would like to
/// disable Apple Pay filtering, set this property to YES.
/// Note: If you are using <code>STPPaymentContext</code>, you should not change this property.
@property (nonatomic) BOOL includeApplePayPaymentMethods;
- (void)retrieveCustomer:(void (^ _Nullable)(STPCustomer * _Nullable, NSError * _Nullable))completion;
- (void)updateCustomerWithShippingAddress:(STPAddress * _Nonnull)shipping completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// A convenience method for attaching the PaymentMethod to the current Customer
- (void)attachPaymentMethodToCustomerWithPaymentMethodId:(NSString * _Nonnull)paymentMethodId completion:(void (^ _Nullable)(NSError * _Nullable))completion;
- (void)attachPaymentMethodToCustomer:(STPPaymentMethod * _Nonnull)paymentMethod completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// A convenience method for detaching the PaymentMethod to the current Customer
- (void)detachPaymentMethodFromCustomerWithPaymentMethodId:(NSString * _Nonnull)paymentMethodId completion:(void (^ _Nullable)(NSError * _Nullable))completion;
- (void)detachPaymentMethodFromCustomer:(STPPaymentMethod * _Nonnull)paymentMethod completion:(void (^ _Nullable)(NSError * _Nullable))completion;
- (void)listPaymentMethodsForCustomerWithCompletion:(void (^ _Nullable)(NSArray<STPPaymentMethod *> * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// You should make your application’s API client conform to this interface.
/// It provides a way for Stripe utility classes to request a new ephemeral key from
/// your backend, which it will use to retrieve and update Stripe API objects.
SWIFT_PROTOCOL("_TtP6Stripe31STPCustomerEphemeralKeyProvider_")
@protocol STPCustomerEphemeralKeyProvider <NSObject>
/// Creates a new ephemeral key for retrieving and updating a Stripe customer.
/// On your backend, you should create a new ephemeral key for the Stripe customer
/// associated with your user, and return the raw JSON response from the Stripe API.
/// For an example Ruby implementation of this API, refer to our example backend:
/// https://github.com/stripe/example-mobile-backend/blob/v18.1.0/web.rb
/// Back in your iOS app, once you have a response from this API, call the provided
/// completion block with the JSON response, or an error if one occurred.
/// \param apiVersion The Stripe API version to use when creating a key.
/// You should pass this parameter to your backend, and use it to set the API version
/// in your key creation request. Passing this version parameter ensures that the
/// Stripe SDK can always parse the ephemeral key response from your server.
///
/// \param completion Call this callback when you’re done fetching a new ephemeral
/// key from your backend. For example, <code>completion(json, nil)</code> (if your call succeeds)
/// or <code>completion(nil, error)</code> if an error is returned.
///
- (void)createCustomerKeyWithAPIVersion:(NSString * _Nonnull)apiVersion completion:(void (^ _Nonnull)(NSDictionary * _Nullable, NSError * _Nullable))completion;
@end


/// You should make your application’s API client conform to this interface.
/// It provides a way for Stripe utility classes to request a new ephemeral key from
/// your backend, which it will use to retrieve and update Stripe API objects.
/// @deprecated use <code>STPCustomerEphemeralKeyProvider</code> or <code>STPIssuingCardEphemeralKeyProvider</code>
/// depending on the type of key that will@objc  be fetched.
SWIFT_PROTOCOL("_TtP6Stripe23STPEphemeralKeyProvider_") SWIFT_DEPRECATED_MSG("use `STPCustomerEphemeralKeyProvider` or `STPIssuingCardEphemeralKeyProvider` depending on the type of key that will be fetched.")
@protocol STPEphemeralKeyProvider <STPCustomerEphemeralKeyProvider>
@end

@class PKAddPaymentPassRequestConfiguration;
@protocol PKAddPaymentPassViewControllerDelegate;

/// This class is a piece of fake UI that is intended to mimic <code>PKAddPaymentPassViewController</code>. That class is restricted to apps with a special entitlement from Apple, and as such can be difficult to build and test against. This class implements the same public API as <code>PKAddPaymentPassViewController</code>, and can be used to develop against the Stripe API in <em>testmode only</em>. (Obviously it will not actually place cards into the user’s Apple Pay wallet either.) When it’s time to go to production, you may simply replace all references to <code>STPFakeAddPaymentPassViewController</code> in your app with <code>PKAddPaymentPassViewController</code> and it will continue to function. For more information on developing against this API, please see https://stripe.com/docs/issuing/cards/digital-wallets .
SWIFT_CLASS("_TtC6Stripe35STPFakeAddPaymentPassViewController")
@interface STPFakeAddPaymentPassViewController : UIViewController
/// @see PKAddPaymentPassViewController
+ (BOOL)canAddPaymentPass SWIFT_WARN_UNUSED_RESULT;
/// @see PKAddPaymentPassViewController
- (nullable instancetype)initWithRequestConfiguration:(PKAddPaymentPassRequestConfiguration * _Nonnull)configuration delegate:(id <PKAddPaymentPassViewControllerDelegate> _Nullable)delegate OBJC_DESIGNATED_INITIALIZER;
/// @see PKAddPaymentPassViewController
@property (nonatomic, weak) id <PKAddPaymentPassViewControllerDelegate> _Nullable delegate;
/// :nodoc:
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder;
/// :nodoc:
- (void)viewDidLoad;
@end


/// You should make your application’s API client conform to this interface.
/// It provides a way for Stripe utility classes to request a new ephemeral key from
/// your backend, which it will use to retrieve and update Stripe API objects.
SWIFT_PROTOCOL("_TtP6Stripe34STPIssuingCardEphemeralKeyProvider_")
@protocol STPIssuingCardEphemeralKeyProvider <NSObject>
/// Creates a new ephemeral key for retrieving and updating a Stripe Issuing Card.
/// On your backend, you should create a new ephemeral key for your logged-in user’s
/// primary Issuing Card, and return the raw JSON response from the Stripe API.
/// For an example Ruby implementation of this API, refer to our example backend:
/// https://github.com/stripe/example-mobile-backend/blob/v18.1.0/web.rb
/// Back in your iOS app, once you have a response from this API, call the provided
/// completion block with the JSON response, or an error if one occurred.
/// \param apiVersion The Stripe API version to use when creating a key.
/// You should pass this parameter to your backend, and use it to set the API version
/// in your key creation request. Passing this version parameter ensures that the
/// Stripe SDK can always parse the ephemeral key response from your server.
///
/// \param completion Call this callback when you’re done fetching a new ephemeral
/// key from your backend. For example, <code>completion(json, nil)</code> (if your call succeeds)
/// or <code>completion(nil, error)</code> if an error is returned.
///
- (void)createIssuingCardKeyWithAPIVersion:(NSString * _Nonnull)apiVersion completion:(void (^ _Nonnull)(NSDictionary * _Nullable, NSError * _Nullable))completion;
@end

@class UIColor;

/// This class can be used wherever you’d use a <code>UIActivityIndicatorView</code> and is intended to have a similar API. It renders as a spinning circle with a gap in it, similar to what you see in the App Store app or in the Apple Pay dialog when making a purchase. To change its color, set the <code>tintColor</code> property.
SWIFT_CLASS("_TtC6Stripe31STPPaymentActivityIndicatorView")
@interface STPPaymentActivityIndicatorView : UIView
/// Tell the view to start or stop spinning. If <code>hidesWhenStopped</code> is true, it will fade in/out if animated is true.
- (void)setAnimating:(BOOL)animating animated:(BOOL)animated;
/// Whether or not the view is animating.
@property (nonatomic) BOOL animating;
/// If true, the view will hide when it is not spinning. Default is true.
@property (nonatomic) BOOL hidesWhenStopped;
/// :nodoc:
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
/// :nodoc:
@property (nonatomic, strong) UIColor * _Null_unspecified tintColor;
/// :nodoc:
- (void)layoutSubviews;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
@end

enum STPShippingType : NSInteger;

/// An <code>STPPaymentConfiguration</code> represents all the options you can set or change
/// around a payment.
/// You provide an <code>STPPaymentConfiguration</code> object to your <code>STPPaymentContext</code>
/// when making a charge. The configuration generally has settings that
/// will not change from payment to payment and thus is reusable, while the context
/// is specific to a single particular payment instance.
SWIFT_CLASS("_TtC6Stripe23STPPaymentConfiguration")
@interface STPPaymentConfiguration : NSObject <NSCopying>
/// This is a convenience singleton configuration that uses the default values for
/// every property
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) STPPaymentConfiguration * _Nonnull sharedConfiguration;)
+ (STPPaymentConfiguration * _Nonnull)sharedConfiguration SWIFT_WARN_UNUSED_RESULT;
+ (void)setSharedConfiguration:(STPPaymentConfiguration * _Nonnull)value;
/// The user is allowed to pay with Apple Pay if it’s configured and available on their device.
@property (nonatomic) BOOL applePayEnabled;
/// The user is allowed to pay with FPX.
@property (nonatomic) BOOL fpxEnabled;
/// The billing address fields the user must fill out when prompted for their
/// payment details. These fields will all be present on the returned PaymentMethod from
/// Stripe.
/// The default value is <code>STPBillingAddressFieldsPostalCode</code>.
/// seealso:
/// https://stripe.com/docs/api/payment_methods/create#create_payment_method-billing_details
@property (nonatomic) enum STPBillingAddressFields requiredBillingAddressFields;
/// The shipping address fields the user must fill out when prompted for their
/// shipping info. Set to nil if shipping address is not required.
/// The default value is nil.
@property (nonatomic, copy) NSSet<STPContactField *> * _Nullable requiredShippingAddressFields;
/// Whether the user should be prompted to verify prefilled shipping information.
/// The default value is YES.
@property (nonatomic) BOOL verifyPrefilledShippingAddress;
/// The type of shipping for this purchase. This property sets the labels displayed
/// when the user is prompted for shipping info, and whether they should also be
/// asked to select a shipping method.
/// The default value is STPShippingTypeShipping.
@property (nonatomic) enum STPShippingType shippingType;
/// The set of countries supported when entering an address. This property accepts
/// a set of ISO 2-character country codes.
/// The default value is all known countries. Setting this property will limit
/// the available countries to your selected set.
@property (nonatomic, copy) NSSet<NSString *> * _Nonnull availableCountries;
/// The name of your company, for displaying to the user during payment flows. For
/// example, when using Apple Pay, the payment sheet’s final line item will read
/// “PAY {companyName}”.
/// The default value is the name of your iOS application which is derived from the
/// <code>kCFBundleNameKey</code> of <code>Bundle.main</code>.
@property (nonatomic, copy) NSString * _Nonnull companyName;
/// The Apple Merchant Identifier to use during Apple Pay transactions. To create
/// one of these, see our guide at https://stripe.com/docs/apple-pay . You
/// must set this to a valid identifier in order to automatically enable Apple Pay.
@property (nonatomic, copy) NSString * _Nullable appleMerchantIdentifier;
/// Determines whether or not the user is able to delete payment options
/// This is only relevant to the <code>STPPaymentOptionsViewController</code> which, if
/// enabled, will allow the user to delete payment options by tapping the “Edit”
/// button in the navigation bar or by swiping left on a payment option and tapping
/// “Delete”. Currently, the user is not allowed to delete the selected payment
/// option but this may change in the future.
/// Default value is YES but will only work if <code>STPPaymentOptionsViewController</code> is
/// initialized with a <code>STPCustomerContext</code> either through the <code>STPPaymentContext</code>
/// or directly as an init parameter.
@property (nonatomic) BOOL canDeletePaymentOptions;
/// Determines whether STPAddCardViewController allows the user to
/// scan cards using the camera on devices running iOS 13 or later.
/// To use this feature, you must also set the <code>NSCameraUsageDescription</code>
/// value in your app’s Info.plist.
/// @note This feature is currently in beta. Please file bugs at
/// https://github.com/stripe/stripe-ios/issues
/// The default value is currently NO. This will be changed in a future update.
@property (nonatomic) BOOL cardScanningEnabled;
/// An enum value representing which payment options you will accept from your user
/// in addition to credit cards.
@property (nonatomic) NSInteger additionalPaymentOptions SWIFT_DEPRECATED_MSG("additionalPaymentOptions has been removed. Set applePayEnabled and fpxEnabled on STPPaymentConfiguration instead.");
/// If you used STPPaymentConfiguration.shared.publishableKey, use STPAPIClient.shared.publishableKey instead.  The SDK uses STPAPIClient.shared to make API requests by default.
/// Your Stripe publishable key
/// seealso:
/// https://dashboard.stripe.com/account/apikeys
@property (nonatomic, copy) NSString * _Nullable publishableKey SWIFT_DEPRECATED_MSG("If you used STPPaymentConfiguration.shared.publishableKey, use STPAPIClient.shared.publishableKey instead. If you passed a STPPaymentConfiguration instance to an SDK component, create an STPAPIClient, set publishableKey on it, and set the SDK component's APIClient property.");
/// If you used STPPaymentConfiguration.shared.stripeAccount, use STPAPIClient.shared.stripeAccount instead.  The SDK uses STPAPIClient.shared to make API requests by default.
/// In order to perform API requests on behalf of a connected account, e.g. to
/// create charges for a connected account, set this property to the ID of the
/// account for which this request is being made.
/// seealso:
/// https://stripe.com/docs/payments#connected-accounts
@property (nonatomic, copy) NSString * _Nullable stripeAccount SWIFT_DEPRECATED_MSG("If you used STPPaymentConfiguration.shared.stripeAccount, use STPAPIClient.shared.stripeAccount instead. If you passed a STPPaymentConfiguration instance to an SDK component, create an STPAPIClient, set stripeAccount on it, and set the SDK component's APIClient property.");
/// :nodoc:
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// :nodoc:
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class STPShippingAddressViewController;
enum STPShippingStatus : NSInteger;
@class PKShippingMethod;

/// An <code>STPShippingAddressViewControllerDelegate</code> is notified when an <code>STPShippingAddressViewController</code> receives an address, completes with an address, or is cancelled.
SWIFT_PROTOCOL("_TtP6Stripe40STPShippingAddressViewControllerDelegate_")
@protocol STPShippingAddressViewControllerDelegate <NSObject>
/// Called when the user cancels entering a shipping address. You should dismiss (or pop) the view controller at this point.
/// \param addressViewController the view controller that has been cancelled
///
- (void)shippingAddressViewControllerDidCancel:(STPShippingAddressViewController * _Nonnull)addressViewController;
/// This is called when the user enters a shipping address and taps next. You
/// should validate the address and determine what shipping methods are available,
/// and call the <code>completion</code> block when finished. If an error occurrs, call
/// the <code>completion</code> block with the error. Otherwise, call the <code>completion</code>
/// block with a nil error and an array of available shipping methods. If you don’t
/// need to collect a shipping method, you may pass an empty array or nil.
/// \param addressViewController the view controller where the address was entered
///
/// \param address the address that was entered. - seealso: STPAddress
///
/// \param completion call this callback when you’re done validating the address and determining available shipping methods.
///
- (void)shippingAddressViewController:(STPShippingAddressViewController * _Nonnull)addressViewController didEnterAddress:(STPAddress * _Nonnull)address completion:(void (^ _Nonnull)(enum STPShippingStatus, NSError * _Nullable, NSArray<PKShippingMethod *> * _Nullable, PKShippingMethod * _Nullable))completion;
/// This is called when the user selects a shipping method. If no shipping methods are given, or if the shipping type doesn’t require a shipping method, this will be called after the user has a shipping address and your validation has succeeded. After updating your app with the user’s shipping info, you should dismiss (or pop) the view controller. Note that if <code>shippingMethod</code> is non-nil, there will be an additional shipping methods view controller on the navigation controller’s stack.
/// \param addressViewController the view controller where the address was entered
///
/// \param address the address that was entered. - seealso: STPAddress
///
/// \param method the shipping method that was selected.
///
- (void)shippingAddressViewController:(STPShippingAddressViewController * _Nonnull)addressViewController didFinishWithAddress:(STPAddress * _Nonnull)address shippingMethod:(PKShippingMethod * _Nullable)method;
@end

@class STPPaymentOptionsViewController;

/// An <code>STPPaymentOptionsViewControllerDelegate</code> responds when a user selects a
/// payment option from (or cancels) an <code>STPPaymentOptionsViewController</code>. In both
/// of these instances, you should dismiss the view controller (either by popping
/// it off the navigation stack, or dismissing it).
SWIFT_PROTOCOL("_TtP6Stripe39STPPaymentOptionsViewControllerDelegate_")
@protocol STPPaymentOptionsViewControllerDelegate <NSObject>
/// This is called when the view controller encounters an error fetching the user’s
/// payment options from its API adapter. You should dismiss the view controller
/// when this is called.
/// \param paymentOptionsViewController the view controller in question
///
/// \param error the error that occurred
///
- (void)paymentOptionsViewController:(STPPaymentOptionsViewController * _Nonnull)paymentOptionsViewController didFailToLoadWithError:(NSError * _Nonnull)error;
/// This is called when the user selects or adds a payment method, so it will often
/// be called immediately after calling <code>paymentOptionsViewController:didSelectPaymentOption:</code>.
/// You should dismiss the view controller when this is called.
/// \param paymentOptionsViewController the view controller that has finished
///
- (void)paymentOptionsViewControllerDidFinish:(STPPaymentOptionsViewController * _Nonnull)paymentOptionsViewController;
/// This is called when the user taps “cancel”.
/// You should dismiss the view controller when this is called.
/// \param paymentOptionsViewController the view controller that has finished
///
- (void)paymentOptionsViewControllerDidCancel:(STPPaymentOptionsViewController * _Nonnull)paymentOptionsViewController;
@optional
/// This is called when the user either makes a selection, or adds a new card.
/// This will be triggered after the view controller loads with the user’s current
/// selection (if they have one) and then subsequently when they change their
/// choice. You should use this callback to update any necessary UI in your app
/// that displays the user’s currently selected payment method. You should <em>not</em>
/// dismiss the view controller at this point, instead do this in
/// <code>paymentOptionsViewControllerDidFinish:</code>. <code>STPPaymentOptionsViewController</code>
/// will also call the necessary methods on your API adapter, so you don’t need to
/// call them directly during this method.
/// \param paymentOptionsViewController the view controller in question
///
/// \param paymentOption the selected payment method
///
- (void)paymentOptionsViewController:(STPPaymentOptionsViewController * _Nonnull)paymentOptionsViewController didSelectPaymentOption:(id <STPPaymentOption> _Nonnull)paymentOption;
@end

@protocol STPPaymentContextDelegate;
@class PKPaymentSummaryItem;

/// An <code>STPPaymentContext</code> keeps track of all of the state around a payment. It will manage fetching a user’s saved payment methods, tracking any information they select, and prompting them for required additional information before completing their purchase. It can be used to power your application’s “payment confirmation” page with just a few lines of code.
/// <code>STPPaymentContext</code> also provides a unified interface to multiple payment methods - for example, you can write a single integration to accept both credit card payments and Apple Pay.
/// <code>STPPaymentContext</code> saves information about a user’s payment methods to a Stripe customer object, and requires an <code>STPCustomerContext</code> to manage retrieving and modifying the customer.
SWIFT_CLASS_NAMED("STPPaymentContext")
@interface STPPaymentContext : NSObject <STPPaymentOptionsViewControllerDelegate, STPShippingAddressViewControllerDelegate, STPAuthenticationContext>
/// This is a convenience initializer; it is equivalent to calling
/// <code>init(customerContext:customerContext configuration:STPPaymentConfiguration.shared theme:STPTheme.defaultTheme</code>.
/// \param customerContext The customer context the payment context will use to fetch
/// and modify its Stripe customer. - seealso: STPCustomerContext.h
///
///
/// returns:
/// the newly-instantiated payment context
- (nonnull instancetype)initWithCustomerContext:(STPCustomerContext * _Nonnull)customerContext;
/// Initializes a new Payment Context with the provided customer context, configuration,
/// and theme. After this class is initialized, you should also make sure to set its
/// <code>delegate</code> and <code>hostViewController</code> properties.
/// seealso:
/// STPPaymentConfiguration.h
/// <ul>
///   <li>
///     theme:             The theme describing the visual appearance of all UI
///     that the payment context automatically creates for you. - seealso: STPTheme.h
///   </li>
/// </ul>
/// \param customerContext The customer context the payment context will use to fetch
/// and modify its Stripe customer. - seealso: STPCustomerContext.h
///
/// \param configuration The configuration for the payment context to use. This
/// lets you set your Stripe publishable API key, required billing address fields, etc.
///
///
/// returns:
/// the newly-instantiated payment context
- (nonnull instancetype)initWithCustomerContext:(STPCustomerContext * _Nonnull)customerContext configuration:(STPPaymentConfiguration * _Nonnull)configuration theme:(STPTheme * _Nonnull)theme;
/// Note: Instead of providing your own backend API adapter, we recommend using
/// <code>STPCustomerContext</code>, which will manage retrieving and updating a
/// Stripe customer for you. - seealso: STPCustomerContext.h
/// This is a convenience initializer; it is equivalent to calling
/// <code>init(apiAdapter:apiAdapter configuration:STPPaymentConfiguration.shared theme:STPTheme.defaultTheme)</code>.
- (nonnull instancetype)initWithApiAdapter:(id <STPBackendAPIAdapter> _Nonnull)apiAdapter;
/// Note: Instead of providing your own backend API adapter, we recommend using
/// <code>STPCustomerContext</code>, which will manage retrieving and updating a
/// Stripe customer for you. - seealso: STPCustomerContext.h
/// Initializes a new Payment Context with the provided API adapter and configuration.
/// After this class is initialized, you should also make sure to set its <code>delegate</code>
/// and <code>hostViewController</code> properties.
/// seealso:
/// STPPaymentConfiguration.h
/// <ul>
///   <li>
///     theme:         The theme describing the visual appearance of all UI that
///     the payment context automatically creates for you. - seealso: STPTheme.h
///   </li>
/// </ul>
/// \param apiAdapter The API adapter the payment context will use to fetch and
/// modify its contents. You need to make a class conforming to this protocol that
/// talks to your server. - seealso: STPBackendAPIAdapter.h
///
/// \param configuration The configuration for the payment context to use. This lets
/// you set your Stripe publishable API key, required billing address fields, etc.
///
///
/// returns:
/// the newly-instantiated payment context
- (nonnull instancetype)initWithApiAdapter:(id <STPBackendAPIAdapter> _Nonnull)apiAdapter configuration:(STPPaymentConfiguration * _Nonnull)configuration theme:(STPTheme * _Nonnull)theme OBJC_DESIGNATED_INITIALIZER;
/// Note: Instead of providing your own backend API adapter, we recommend using
/// <code>STPCustomerContext</code>, which will manage retrieving and updating a
/// Stripe customer for you. - seealso: STPCustomerContext.h
/// The API adapter the payment context will use to fetch and modify its contents.
/// You need to make a class conforming to this protocol that talks to your server.
/// seealso:
/// STPBackendAPIAdapter.h
@property (nonatomic, readonly, strong) id <STPBackendAPIAdapter> _Nonnull apiAdapter;
/// The configuration for the payment context to use internally. - seealso: STPPaymentConfiguration.h
@property (nonatomic, readonly, strong) STPPaymentConfiguration * _Nonnull configuration;
/// The visual appearance that will be used by any views that the context generates. - seealso: STPTheme.h
@property (nonatomic, readonly, strong) STPTheme * _Nonnull theme;
/// If you’ve already collected some information from your user, you can set it here and it’ll be automatically filled out when possible/appropriate in any UI that the payment context creates.
@property (nonatomic, strong) STPUserInformation * _Nullable prefilledInformation;
/// The view controller that any additional UI will be presented on. If you have a “checkout view controller” in your app, that should be used as the host view controller.
@property (nonatomic, weak) UIViewController * _Nullable hostViewController;
/// This delegate will be notified when the payment context’s contents change. - seealso: STPPaymentContextDelegate
@property (nonatomic, weak) id <STPPaymentContextDelegate> _Nullable delegate;
/// Whether or not the payment context is currently loading information from the network.
@property (nonatomic, readonly) BOOL loading;
/// @note This is no longer recommended as of v18.3.0 - the SDK automatically saves the Stripe ID of the last selected
/// payment method using NSUserDefaults and displays it as the default pre-selected option.  You can override this behavior
/// by setting this property.
/// The Stripe ID of a payment method to display as the default pre-selected option.
/// @note Set this property immediately after initializing STPPaymentContext, or call <code>retryLoading</code> afterwards.
@property (nonatomic, copy) NSString * _Nullable defaultPaymentMethod;
/// The user’s currently selected payment option. May be nil.
@property (nonatomic, readonly, strong) id <STPPaymentOption> _Nullable selectedPaymentOption;
/// The available payment options the user can choose between. May be nil.
@property (nonatomic, readonly, copy) NSArray<id <STPPaymentOption>> * _Nullable paymentOptions;
/// The user’s currently selected shipping method. May be nil.
@property (nonatomic, readonly, strong) PKShippingMethod * _Nullable selectedShippingMethod;
/// An array of STPShippingMethod objects that describe the supported shipping methods. May be nil.
@property (nonatomic, readonly, copy) NSArray<PKShippingMethod *> * _Nullable shippingMethods;
/// The user’s shipping address. May be nil.
/// If you’ve already collected a shipping address from your user, you may
/// prefill it by setting a shippingAddress in PaymentContext’s prefilledInformation.
/// When your user enters a new shipping address, PaymentContext will save it to
/// the current customer object. When PaymentContext loads, if you haven’t
/// manually set a prefilled value, any shipping information saved on the customer
/// will be used to prefill the shipping address form. Note that because your
/// customer’s email may not be the same as the email provided with their shipping
/// info, PaymentContext will not prefill the shipping form’s email using your
/// customer’s email.
/// You should not rely on the shipping information stored on the Stripe customer
/// for order fulfillment, as your user may change this information if they make
/// multiple purchases. We recommend adding shipping information when you create
/// a charge (which can also help prevent fraud), or saving it to your own
/// database. https://stripe.com/docs/api/payment_intents/create#create_payment_intent-shipping
/// Note: by default, your user will still be prompted to verify a prefilled
/// shipping address. To change this behavior, you can set
/// <code>verifyPrefilledShippingAddress</code> to NO in your <code>STPPaymentConfiguration</code>.
@property (nonatomic, readonly, strong) STPAddress * _Nullable shippingAddress;
/// The amount of money you’re requesting from the user, in the smallest currency
/// unit for the selected currency. For example, to indicate $10 USD, use 1000
/// (i.e. 1000 cents). For more information, see https://stripe.com/docs/api/payment_intents/create#create_payment_intent-amount
/// @note This value must be present and greater than zero in order for Apple Pay
/// to be automatically enabled.
/// @note You should only set either this or <code>paymentSummaryItems</code>, not both.
/// The other will be automatically calculated on demand using your <code>paymentCurrency</code>.
@property (nonatomic) NSInteger paymentAmount;
/// The three-letter currency code for the currency of the payment (i.e. USD, GBP,
/// JPY, etc). Defaults to “USD”.
/// @note Changing this property may change the return value of <code>paymentAmount</code>
/// or <code>paymentSummaryItems</code> (whichever one you didn’t directly set yourself).
@property (nonatomic, copy) NSString * _Nonnull paymentCurrency;
/// The two-letter country code for the country where the payment will be processed.
/// You should set this to the country your Stripe account is in. Defaults to “US”.
/// @note Changing this property will change the <code>countryCode</code> of your Apple Pay
/// payment requests.
/// seealso:
/// PKPaymentRequest for more information.
@property (nonatomic, copy) NSString * _Nonnull paymentCountry;
/// If you support Apple Pay, you can optionally set the PKPaymentSummaryItems
/// you want to display here instead of using <code>paymentAmount</code>. Note that the
/// grand total (the amount of the last summary item) must be greater than zero.
/// If not set, a single summary item will be automatically generated using
/// <code>paymentAmount</code> and your configuration’s <code>companyName</code>.
/// seealso:
/// PKPaymentRequest for more information
/// @note You should only set either this or <code>paymentAmount</code>, not both.
/// The other will be automatically calculated on demand using your <code>paymentCurrency.</code>
@property (nonatomic, copy) NSArray<PKPaymentSummaryItem *> * _Nonnull paymentSummaryItems;
@property (nonatomic) PKApplePayLaterAvailability applePayLaterAvailability SWIFT_AVAILABILITY(ios,introduced=17.0) SWIFT_AVAILABILITY(macos,introduced=14.0);
/// The presentation style used for all view controllers presented modally by the context.
/// Since custom transition styles are not supported, you should set this to either
/// <code>UIModalPresentationFullScreen</code>, <code>UIModalPresentationPageSheet</code>, or <code>UIModalPresentationFormSheet</code>.
/// The default value is <code>UIModalPresentationFullScreen</code>.
@property (nonatomic) UIModalPresentationStyle modalPresentationStyle;
/// The mode to use when displaying the title of the navigation bar in all view
/// controllers presented by the context. The default value is <code>automatic</code>,
/// which causes the title to use the same styling as the previously displayed
/// navigation item (if the view controller is pushed onto the <code>hostViewController</code>).
/// If the <code>prefersLargeTitles</code> property of the <code>hostViewController</code>‘s navigation bar
/// is false, this property has no effect and the navigation item’s title is always
/// displayed as a small title.
/// If the view controller is presented modally, <code>automatic</code> and
/// <code>never</code> always result in a navigation bar with a small title.
@property (nonatomic) UINavigationItemLargeTitleDisplayMode largeTitleDisplayMode;
/// A view that will be placed as the footer of the payment options selection
/// view controller.
/// When the footer view needs to be resized, it will be sent a
/// <code>sizeThatFits:</code> call. The view should respond correctly to this method in order
/// to be sized and positioned properly.
@property (nonatomic, strong) UIView * _Nullable paymentOptionsViewControllerFooterView;
/// A view that will be placed as the footer of the add card view controller.
/// When the footer view needs to be resized, it will be sent a
/// <code>sizeThatFits:</code> call. The view should respond correctly to this method in order
/// to be sized and positioned properly.
@property (nonatomic, strong) UIView * _Nullable addCardViewControllerFooterView;
/// If <code>paymentContext:didFailToLoadWithError:</code> is called on your delegate, you
/// can in turn call this method to try loading again (if that hasn’t been called,
/// calling this will do nothing). If retrying in turn fails, <code>paymentContext:didFailToLoadWithError:</code>
/// will be called again (and you can again call this to keep retrying, etc).
- (void)retryLoading;
/// This creates, configures, and appropriately presents an <code>STPPaymentOptionsViewController</code>
/// on top of the payment context’s <code>hostViewController</code>. It’ll be dismissed automatically
/// when the user is done selecting their payment method.
/// @note This method will do nothing if it is called while STPPaymentContext is
/// already showing a view controller or in the middle of requesting a payment.
- (void)presentPaymentOptionsViewController;
/// This creates, configures, and appropriately pushes an <code>STPPaymentOptionsViewController</code>
/// onto the navigation stack of the context’s <code>hostViewController</code>. It’ll be popped
/// automatically when the user is done selecting their payment method.
/// @note This method will do nothing if it is called while STPPaymentContext is
/// already showing a view controller or in the middle of requesting a payment.
- (void)pushPaymentOptionsViewController;
/// This creates, configures, and appropriately presents a view controller for
/// collecting shipping address and shipping method on top of the payment context’s
/// <code>hostViewController</code>. It’ll be dismissed automatically when the user is done
/// entering their shipping info.
/// @note This method will do nothing if it is called while STPPaymentContext is
/// already showing a view controller or in the middle of requesting a payment.
- (void)presentShippingViewController;
/// This creates, configures, and appropriately pushes a view controller for
/// collecting shipping address and shipping method onto the navigation stack of
/// the context’s <code>hostViewController</code>. It’ll be popped automatically when the
/// user is done entering their shipping info.
/// @note This method will do nothing if it is called while STPPaymentContext is
/// already showing a view controller, or in the middle of requesting a payment.
- (void)pushShippingViewController;
/// Requests payment from the user. This may need to present some supplemental UI
/// to the user, in which case it will be presented on the payment context’s
/// <code>hostViewController</code>. For instance, if they’ve selected Apple Pay as their
/// payment method, calling this method will show the payment sheet. If the user
/// has a card on file, this will use that without presenting any additional UI.
/// After this is called, the <code>paymentContext:didCreatePaymentResult:completion:</code>
/// and <code>paymentContext:didFinishWithStatus:error:</code> methods will be called on the
/// context’s <code>delegate</code>.
/// @note This method will do nothing if it is called while STPPaymentContext is
/// already showing a view controller, or in the middle of requesting a payment.
- (void)requestPayment;
- (void)paymentOptionsViewController:(STPPaymentOptionsViewController * _Nonnull)paymentOptionsViewController didSelectPaymentOption:(id <STPPaymentOption> _Nonnull)paymentOption;
- (void)paymentOptionsViewControllerDidFinish:(STPPaymentOptionsViewController * _Nonnull)paymentOptionsViewController;
- (void)paymentOptionsViewControllerDidCancel:(STPPaymentOptionsViewController * _Nonnull)paymentOptionsViewController;
- (void)paymentOptionsViewController:(STPPaymentOptionsViewController * _Nonnull)paymentOptionsViewController didFailToLoadWithError:(NSError * _Nonnull)error;
- (void)shippingAddressViewControllerDidCancel:(STPShippingAddressViewController * _Nonnull)addressViewController;
- (void)shippingAddressViewController:(STPShippingAddressViewController * _Nonnull)addressViewController didEnterAddress:(STPAddress * _Nonnull)address completion:(void (^ _Nonnull)(enum STPShippingStatus, NSError * _Nullable, NSArray<PKShippingMethod *> * _Nullable, PKShippingMethod * _Nullable))completion;
- (void)shippingAddressViewController:(STPShippingAddressViewController * _Nonnull)addressViewController didFinishWithAddress:(STPAddress * _Nonnull)address shippingMethod:(PKShippingMethod * _Nullable)method;
- (UIViewController * _Nonnull)authenticationPresentingViewController SWIFT_WARN_UNUSED_RESULT;
- (void)prepareAuthenticationContextForPresentation:(void (^ _Nonnull)(void))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@class STPPaymentResult;

/// Implement <code>STPPaymentContextDelegate</code> to get notified when a payment context changes, finishes, encounters errors, etc. In practice, if your app has a “checkout screen view controller”, that is a good candidate to implement this protocol.
SWIFT_PROTOCOL("_TtP6Stripe25STPPaymentContextDelegate_")
@protocol STPPaymentContextDelegate <NSObject>
/// Called when the payment context encounters an error when fetching its initial set of data. A few ways to handle this are:
/// <ul>
///   <li>
///     If you’re showing the user a checkout page, dismiss the checkout page when this is called and present the error to the user.
///   </li>
///   <li>
///     Present the error to the user using a <code>UIAlertController</code> with two buttons: Retry and Cancel. If they cancel, dismiss your UI. If they Retry, call <code>retryLoading</code> on the payment context.
///     To make it harder to get your UI into a bad state, this won’t be called until the context’s <code>hostViewController</code> has finished appearing.
///   </li>
/// </ul>
/// \param paymentContext the payment context that encountered the error
///
/// \param error the error that was encountered
///
- (void)paymentContext:(STPPaymentContext * _Nonnull)paymentContext didFailToLoadWithError:(NSError * _Nonnull)error;
/// This is called every time the contents of the payment context change. When this is called, you should update your app’s UI to reflect the current state of the payment context. For example, if you have a checkout page with a “selected payment method” row, you should update its payment method with <code>paymentContext.selectedPaymentOption.label</code>. If that checkout page has a “buy” button, you should enable/disable it depending on the result of <code>paymentContext.isReadyForPayment</code>.
/// \param paymentContext the payment context that changed
///
- (void)paymentContextDidChange:(STPPaymentContext * _Nonnull)paymentContext;
/// Inside this method, you should make a call to your backend API to make a PaymentIntent with that Customer + payment method, and invoke the <code>completion</code> block when that is done.
/// \param paymentContext The context that succeeded
///
/// \param paymentResult Information associated with the payment that you can pass to your server. You should go to your backend API with this payment result and use the PaymentIntent API to complete the payment. See https://stripe.com/docs/mobile/ios/basic#submit-payment-intents Once that’s done call the <code>completion</code> block with any error that occurred (or none, if the payment succeeded). - seealso: STPPaymentResult.h
///
/// \param completion Call this block when you’re done creating a payment intent (or subscription, etc) on your backend. If it succeeded, call <code>completion(STPPaymentStatusSuccess, nil)</code>. If it failed with an error, call <code>completion(STPPaymentStatusError, error)</code>. If the user canceled, call <code>completion(STPPaymentStatusUserCancellation, nil)</code>.
///
- (void)paymentContext:(STPPaymentContext * _Nonnull)paymentContext didCreatePaymentResult:(STPPaymentResult * _Nonnull)paymentResult completion:(void (^ _Nonnull)(enum STPPaymentStatus, NSError * _Nullable))completion;
/// This is invoked by an <code>STPPaymentContext</code> when it is finished. This will be called after the payment is done and all necessary UI has been dismissed. You should inspect the returned <code>status</code> and behave appropriately. For example: if it’s <code>STPPaymentStatusSuccess</code>, show the user a receipt. If it’s <code>STPPaymentStatusError</code>, inform the user of the error. If it’s <code>STPPaymentStatusUserCancellation</code>, do nothing.
/// \param paymentContext The payment context that finished
///
/// \param status The status of the payment - <code>STPPaymentStatusSuccess</code> if it succeeded, <code>STPPaymentStatusError</code> if it failed with an error (in which case the <code>error</code> parameter will be non-nil), <code>STPPaymentStatusUserCancellation</code> if the user canceled the payment.
///
/// \param error An error that occurred, if any.
///
- (void)paymentContext:(STPPaymentContext * _Nonnull)paymentContext didFinishWith:(enum STPPaymentStatus)status error:(NSError * _Nullable)error;
@optional
/// Inside this method, you should verify that you can ship to the given address.
/// You should call the completion block with the results of your validation
/// and the available shipping methods for the given address. If you don’t implement
/// this method, the user won’t be prompted to select a shipping method and all
/// addresses will be valid. If you call the completion block with nil or an
/// empty array of shipping methods, the user won’t be prompted to select a
/// shipping method.
/// @note If a user updates their shipping address within the Apple Pay dialog,
/// this address will be anonymized. For example, in the US, it will only include the
/// city, state, and zip code. The payment context will have the user’s complete
/// shipping address by the time <code>paymentContext:didFinishWithStatus:error</code> is
/// called.
/// \param paymentContext The context that updated its shipping address
///
/// \param address The current shipping address
///
/// \param completion Call this block when you’re done validating the shipping
/// address and calculating available shipping methods. If you call the completion
/// block with nil or an empty array of shipping methods, the user won’t be prompted
/// to select a shipping method.
///
- (void)paymentContext:(STPPaymentContext * _Nonnull)paymentContext didUpdateShippingAddress:(STPAddress * _Nonnull)address completion:(void (^ _Nonnull)(enum STPShippingStatus, NSError * _Nullable, NSArray<PKShippingMethod *> * _Nullable, PKShippingMethod * _Nullable))completion;
@end


@interface STPPaymentIntentParams (SWIFT_EXTENSION(Stripe))
/// Provide an STPPaymentResult from STPPaymentContext, and this will populate
/// the proper field (either paymentMethodId or paymentMethodParams) for your PaymentMethod.
- (void)configureWith:(STPPaymentResult * _Nonnull)paymentResult;
@end


@interface STPPaymentMethod (SWIFT_EXTENSION(Stripe)) <STPPaymentOption>
@property (nonatomic, readonly, strong) UIImage * _Nonnull image;
@property (nonatomic, readonly, strong) UIImage * _Nonnull templateImage;
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
@property (nonatomic, readonly) BOOL isReusable;
@end


@interface STPPaymentMethodParams (SWIFT_EXTENSION(Stripe)) <STPPaymentOption>
@property (nonatomic, readonly, strong) UIImage * _Nonnull image;
@property (nonatomic, readonly, strong) UIImage * _Nonnull templateImage;
@property (nonatomic, readonly) BOOL isReusable;
@end



/// This view controller presents a list of payment method options to the user,
/// which they can select between. They can also add credit cards to the list.
/// It must be displayed inside a <code>UINavigationController</code>, so you can either
/// create a <code>UINavigationController</code> with an <code>STPPaymentOptionsViewController</code>
/// as the <code>rootViewController</code> and then present the <code>UINavigationController</code>,
/// or push a new <code>STPPaymentOptionsViewController</code> onto an existing
/// <code>UINavigationController</code>’s stack. You can also have <code>STPPaymentContext</code> do this
/// for you automatically, by calling <code>presentPaymentOptionsViewController</code>
/// or <code>pushPaymentOptionsViewController</code> on it.
SWIFT_CLASS("_TtC6Stripe31STPPaymentOptionsViewController")
@interface STPPaymentOptionsViewController : STPCoreViewController <STPAddCardViewControllerDelegate>
/// Creates a new payment methods view controller.
/// \param paymentContext A payment context to power the view controller’s view.
/// The payment context will in turn use its backend API adapter to fetch the
/// information it needs from your application.
///
///
/// returns:
/// an initialized view controller.
- (nonnull instancetype)initWithPaymentContext:(STPPaymentContext * _Nonnull)paymentContext;
/// Initializes a new payment methods view controller without using a
/// payment context.
/// \param configuration The configuration to use to determine what types of
/// payment method to offer your user. - seealso: STPPaymentConfiguration.h
///
/// \param theme The theme to inform the appearance of the UI.
///
/// \param customerContext The customer context the view controller will use to
/// fetch and modify its Stripe customer
///
/// \param delegate A delegate that will be notified when the payment
/// methods view controller’s selection changes.
///
///
/// returns:
/// an initialized view controller.
- (nonnull instancetype)initWithConfiguration:(STPPaymentConfiguration * _Nonnull)configuration theme:(STPTheme * _Nonnull)theme customerContext:(STPCustomerContext * _Nonnull)customerContext delegate:(id <STPPaymentOptionsViewControllerDelegate> _Nonnull)delegate;
/// Note: Instead of providing your own backend API adapter, we recommend using
/// <code>STPCustomerContext</code>, which will manage retrieving and updating a
/// Stripe customer for you. - seealso: STPCustomerContext.h
/// Initializes a new payment methods view controller without using
/// a payment context.
/// \param configuration The configuration to use to determine what types of
/// payment method to offer your user.
///
/// \param theme The theme to inform the appearance of the UI.
///
/// \param apiAdapter The API adapter to use to retrieve a customer’s stored
/// payment methods and save new ones.
///
/// \param delegate A delegate that will be notified when the payment methods
/// view controller’s selection changes.
///
- (nonnull instancetype)initWithConfiguration:(STPPaymentConfiguration * _Nonnull)configuration theme:(STPTheme * _Nonnull)theme apiAdapter:(id <STPBackendAPIAdapter> _Nonnull)apiAdapter delegate:(id <STPPaymentOptionsViewControllerDelegate> _Nonnull)delegate OBJC_DESIGNATED_INITIALIZER;
/// If you’ve already collected some information from your user, you can set it
/// here and it’ll be automatically filled out when possible/appropriate in any UI
/// that the payment context creates.
@property (nonatomic, strong) STPUserInformation * _Nullable prefilledInformation;
/// @note This is no longer recommended as of v18.3.0 - the SDK automatically saves the Stripe ID of the last selected
/// payment method using NSUserDefaults and displays it as the default pre-selected option.  You can override this behavior
/// by setting this property.
/// The Stripe ID of a payment method to display as the default pre-selected option.
/// @note Setting this after the view controller’s view has loaded has no effect.
@property (nonatomic, copy) NSString * _Nullable defaultPaymentMethod;
/// A view that will be placed as the footer of the view controller when it is
/// showing a list of saved payment methods to select from.
/// When the footer view needs to be resized, it will be sent a
/// <code>sizeThatFits:</code> call. The view should respond correctly to this method in order
/// to be sized and positioned properly.
@property (nonatomic, strong) UIView * _Nullable paymentOptionsViewControllerFooterView;
/// A view that will be placed as the footer of the view controller when it is
/// showing the add card view.
/// When the footer view needs to be resized, it will be sent a
/// <code>sizeThatFits:</code> call. The view should respond correctly to this method in order
/// to be sized and positioned properly.
@property (nonatomic, strong) UIView * _Nullable addCardViewControllerFooterView;
/// If you’re pushing <code>STPPaymentOptionsViewController</code> onto an existing
/// <code>UINavigationController</code>‘s stack, you should use this method to dismiss it,
/// since it may have pushed an additional add card view controller onto the
/// navigation controller’s stack.
/// \param completion The callback to run after the view controller is dismissed.
/// You may specify nil for this parameter.
///
- (void)dismissWithCompletion:(void (^ _Nullable)(void))completion;
/// Use one of the initializers declared in this interface.
- (nonnull instancetype)initWithTheme:(STPTheme * _Nullable)theme OBJC_DESIGNATED_INITIALIZER SWIFT_UNAVAILABLE_MSG("Use one of the initializers declared in this interface instead.");
/// Use one of the initializers declared in this interface.
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER SWIFT_UNAVAILABLE_MSG("Use one of the initializers declared in this interface instead.");
/// Use one of the initializers declared in this interface.
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER SWIFT_UNAVAILABLE_MSG("Use one of the initializers declared in this interface instead.");
/// :nodoc:
- (void)viewDidLayoutSubviews;
/// :nodoc:
- (void)viewDidAppear:(BOOL)animated;
- (void)addCardViewControllerDidCancel:(STPAddCardViewController * _Nonnull)addCardViewController;
- (void)addCardViewController:(STPAddCardViewController * _Nonnull)addCardViewController didCreatePaymentMethod:(STPPaymentMethod * _Nonnull)paymentMethod completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
@end




/// When you’re using <code>STPPaymentContext</code> to request your user’s payment details, this is the object that will be returned to your application when they’ve successfully made a payment.
/// See https://stripe.com/docs/mobile/ios/basic#submit-payment-intents
SWIFT_CLASS("_TtC6Stripe16STPPaymentResult")
@interface STPPaymentResult : NSObject
/// The payment method that the user has selected. This may come from a variety of different payment methods, such as an Apple Pay payment or a stored credit card. - seealso: STPPaymentMethod.h
/// If paymentMethod is nil, paymentMethodParams will be populated instead.
@property (nonatomic, readonly, strong) STPPaymentMethod * _Nullable paymentMethod;
/// The parameters for a payment method that the user has selected. This is
/// populated for non-reusable payment methods, such as FPX and iDEAL. - seealso: STPPaymentMethodParams.h
/// If paymentMethodParams is nil, paymentMethod will be populated instead.
@property (nonatomic, readonly, strong) STPPaymentMethodParams * _Nullable paymentMethodParams;
/// The STPPaymentOption that was used to initialize this STPPaymentResult, either an STPPaymentMethod or an STPPaymentMethodParams.
@property (nonatomic, readonly, weak) id <STPPaymentOption> _Nullable paymentOption;
/// Initializes the payment result with a given payment option. This is invoked by <code>STPPaymentContext</code> internally; you shouldn’t have to call it directly.
- (nonnull instancetype)initWithPaymentOption:(id <STPPaymentOption> _Nullable)paymentOption OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class STPIssuingCardPin;

/// STPAPIClient extensions to manage PIN on Stripe Issuing cards
SWIFT_CLASS("_TtC6Stripe23STPPinManagementService") SWIFT_AVAILABILITY(ios,deprecated=100000.0,message="Please use Issuing Elements instead: https://stripe.com/docs/issuing/elements")
@interface STPPinManagementService : NSObject
/// Create a STPPinManagementService, you must provide an implementation of STPIssuingCardEphemeralKeyProvider
- (nonnull instancetype)initWithKeyProvider:(id <STPIssuingCardEphemeralKeyProvider> _Nonnull)keyProvider OBJC_DESIGNATED_INITIALIZER;
/// Retrieves a PIN number for a given card,
/// this call is asynchronous, implement the completion block to receive the updates
- (void)retrievePin:(NSString * _Nonnull)cardId verificationId:(NSString * _Nonnull)verificationId oneTimeCode:(NSString * _Nonnull)oneTimeCode completion:(void (^ _Nonnull)(STPIssuingCardPin * _Nullable, enum STPPinStatus, NSError * _Nullable))completion;
/// Updates a PIN number for a given card,
/// this call is asynchronous, implement the completion block to receive the updates
- (void)updatePin:(NSString * _Nonnull)cardId newPin:(NSString * _Nonnull)newPin verificationId:(NSString * _Nonnull)verificationId oneTimeCode:(NSString * _Nonnull)oneTimeCode completion:(void (^ _Nonnull)(STPIssuingCardPin * _Nullable, enum STPPinStatus, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class PKAddPaymentPassViewController;
@class NSData;
@class PKAddPaymentPassRequest;

/// This class makes it easier to implement “Push Provisioning”, the process by which an end-user can add a card to their Apple Pay wallet without having to type their number. This process is mediated by an Apple class called <code>PKAddPaymentPassViewController</code>; this class will help you implement that class’ delegate methods. Note that this flow requires a special entitlement from Apple; for more information please see https://stripe.com/docs/issuing/cards/digital-wallets .
SWIFT_CLASS("_TtC6Stripe26STPPushProvisioningContext")
@interface STPPushProvisioningContext : NSObject
/// This is a helper method to generate a PKAddPaymentPassRequestConfiguration that will work with
/// Stripe’s Issuing APIs. Pass the returned configuration object to <code>PKAddPaymentPassViewController</code>’s <code>initWithRequestConfiguration:delegate:</code> initializer.
/// @deprecated Use requestConfiguration(withName:description:last4:brand:primaryAccountIdentifier:) instead.
/// \param name Your cardholder’s name. Example: John Appleseed
///
/// \param description A localized description of your card’s name. This will appear in Apple’s UI as “{description} will be available in Wallet”. Example: Platinum Rewards Card
///
/// \param last4 The last 4 of the card to be added to the user’s Apple Pay wallet. Example: 4242
///
/// \param brand The brand of the card. Example: <code>STPCardBrandVisa</code>
///
+ (PKAddPaymentPassRequestConfiguration * _Nonnull)requestConfigurationWithName:(NSString * _Nonnull)name description:(NSString * _Nullable)description last4:(NSString * _Nullable)last4 brand:(enum STPCardBrand)brand SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("Use `requestConfiguration(withName:description:last4:brand:primaryAccountIdentifier:)` instead.", "requestConfigurationWithName:description:last4:brand:primaryAccountIdentifier:");
/// This is a helper method to generate a PKAddPaymentPassRequestConfiguration that will work with
/// Stripe’s Issuing APIs. Pass the returned configuration object to <code>PKAddPaymentPassViewController</code>’s <code>initWithRequestConfiguration:delegate:</code> initializer.
/// \param name Your cardholder’s name. Example: John Appleseed
///
/// \param description A localized description of your card’s name. This will appear in Apple’s UI as “{description} will be available in Wallet”. Example: Platinum Rewards Card
///
/// \param last4 The last 4 of the card to be added to the user’s Apple Pay wallet. Example: 4242
///
/// \param brand The brand of the card. Example: <code>STPCardBrandVisa</code>
///
/// \param primaryAccountIdentifier The <code>primary_account_identifier</code> value from the issued card.
///
+ (PKAddPaymentPassRequestConfiguration * _Nonnull)requestConfigurationWithName:(NSString * _Nonnull)name description:(NSString * _Nullable)description last4:(NSString * _Nullable)last4 brand:(enum STPCardBrand)brand primaryAccountIdentifier:(NSString * _Nullable)primaryAccountIdentifier SWIFT_WARN_UNUSED_RESULT;
/// In order to retreive the encrypted payload that PKAddPaymentPassViewController expects, the Stripe SDK must talk to the Stripe API. As this requires privileged access, you must write a “key provider” that generates an Ephemeral Key on your backend and provides it to the SDK when requested. For more information, see https://stripe.com/docs/mobile/ios/basic#ephemeral-key
- (nonnull instancetype)initWithKeyProvider:(id <STPIssuingCardEphemeralKeyProvider> _Nonnull)keyProvider OBJC_DESIGNATED_INITIALIZER;
/// This method lines up with the method of the same name on <code>PKAddPaymentPassViewControllerDelegate</code>. You should implement that protocol in your own app, and when that method is called, call this method on your <code>STPPushProvisioningContext</code>. This in turn will first initiate a call to your <code>keyProvider</code> (see above) to obtain an Ephemeral Key, then make a call to the Stripe Issuing API to fetch an encrypted payload for the card in question, then return that payload to iOS.
- (void)addPaymentPassViewController:(PKAddPaymentPassViewController * _Nonnull)controller generateRequestWithCertificateChain:(NSArray<NSData *> * _Nonnull)certificates nonce:(NSData * _Nonnull)nonce nonceSignature:(NSData * _Nonnull)nonceSignature completionHandler:(void (^ _Nonnull)(PKAddPaymentPassRequest * _Nonnull))handler;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A helper class for turning the raw certificate array, nonce, and nonce signature emitted by PKAddPaymentPassViewController into a format that is understandable by the Stripe API.
/// If you are using STPPushProvisioningContext to implement your integration, you do not need to use this class.
SWIFT_CLASS("_TtC6Stripe32STPPushProvisioningDetailsParams")
@interface STPPushProvisioningDetailsParams : NSObject
/// The Stripe ID of the Issuing card object to retrieve details for.
@property (nonatomic, readonly, copy) NSString * _Nonnull cardId;
/// An array of certificates that should be used to encrypt the card details.
@property (nonatomic, readonly, copy) NSArray<NSData *> * _Nonnull certificates;
/// A nonce that should be used during the encryption of the card details.
@property (nonatomic, readonly, copy) NSData * _Nonnull nonce;
/// A nonce signature that should be used during the encryption of the card details.
@property (nonatomic, readonly, copy) NSData * _Nonnull nonceSignature;
/// Implemented for convenience - the Stripe API expects the certificate chain as an array of base64-encoded strings.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull certificatesBase64;
/// Implemented for convenience - the Stripe API expects the nonce as a hex-encoded string.
@property (nonatomic, readonly, copy) NSString * _Nonnull nonceHex;
/// Implemented for convenience - the Stripe API expects the nonce signature as a hex-encoded string.
@property (nonatomic, readonly, copy) NSString * _Nonnull nonceSignatureHex;
/// Instantiates a new params object with the provided attributes.
- (nonnull instancetype)initWithCardId:(NSString * _Nonnull)cardId certificates:(NSArray<NSData *> * _Nonnull)certificates nonce:(NSData * _Nonnull)nonce nonceSignature:(NSData * _Nonnull)nonceSignature OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// This view controller contains a shipping address collection form. It renders a right bar button item that submits the form, so it must be shown inside a <code>UINavigationController</code>. Depending on your configuration’s shippingType, the view controller may present a shipping method selection form after the user enters an address.
SWIFT_CLASS("_TtC6Stripe32STPShippingAddressViewController")
@interface STPShippingAddressViewController : STPCoreTableViewController
/// A convenience initializer; equivalent to calling <code>init(configuration: STPPaymentConfiguration.shared theme: STPTheme.defaultTheme currency:"" shippingAddress:nil selectedShippingMethod:nil prefilledInformation:nil)</code>.
- (nonnull instancetype)init;
/// Initializes a new <code>STPShippingAddressViewController</code> with the given payment context and sets the payment context as its delegate.
/// \param paymentContext The payment context to use.
///
- (nonnull instancetype)initWithPaymentContext:(STPPaymentContext * _Nonnull)paymentContext;
/// Initializes a new <code>STPShippingAddressCardViewController</code> with the provided parameters.
/// \param configuration The configuration to use (this determines the required shipping address fields and shipping type). - seealso: STPPaymentConfiguration
///
/// \param theme The theme to use to inform the view controller’s visual appearance. - seealso: STPTheme
///
/// \param currency The currency to use when displaying amounts for shipping methods. The default is USD.
///
/// \param shippingAddress If set, the shipping address view controller will be pre-filled with this address. - seealso: STPAddress
///
/// \param selectedShippingMethod If set, the shipping methods view controller will use this method as the selected shipping method. If <code>selectedShippingMethod</code> is nil, the first shipping method in the array of methods returned by your delegate will be selected.
///
/// \param prefilledInformation If set, the shipping address view controller will be pre-filled with this information. - seealso: STPUserInformation
///
- (nonnull instancetype)initWithConfiguration:(STPPaymentConfiguration * _Nonnull)configuration theme:(STPTheme * _Nonnull)theme currency:(NSString * _Nullable)currency shippingAddress:(STPAddress * _Nullable)shippingAddress selectedShippingMethod:(PKShippingMethod * _Nullable)selectedShippingMethod prefilledInformation:(STPUserInformation * _Nullable)prefilledInformation OBJC_DESIGNATED_INITIALIZER;
/// The view controller’s delegate. This must be set before showing the view controller in order for it to work properly. - seealso: STPShippingAddressViewControllerDelegate
@property (nonatomic, weak) id <STPShippingAddressViewControllerDelegate> _Nullable delegate;
/// If you’re pushing <code>STPShippingAddressViewController</code> onto an existing <code>UINavigationController</code>‘s stack, you should use this method to dismiss it, since it may have pushed an additional shipping method view controller onto the navigation controller’s stack.
/// \param completion The callback to run after the view controller is dismissed. You may specify nil for this parameter.
///
- (void)dismissWithCompletion:(void (^ _Nullable)(void))completion;
/// Use one of the initializers declared in this interface.
- (nonnull instancetype)initWithTheme:(STPTheme * _Nullable)theme OBJC_DESIGNATED_INITIALIZER SWIFT_UNAVAILABLE_MSG("Use one of the initializers declared in this interface instead.");
/// Use one of the initializers declared in this interface.
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER SWIFT_UNAVAILABLE_MSG("Use one of the initializers declared in this interface instead.");
/// Use one of the initializers declared in this interface.
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// :nodoc:
- (void)viewDidAppear:(BOOL)animated;
/// :nodoc:
- (CGFloat)tableView:(UITableView * _Nonnull)tableView heightForHeaderInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
@end



@interface STPShippingAddressViewController (SWIFT_EXTENSION(Stripe)) <UITableViewDataSource, UITableViewDelegate>
/// :nodoc:
- (NSInteger)numberOfSectionsInTableView:(UITableView * _Nonnull)tableView SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (NSInteger)tableView:(UITableView * _Nonnull)tableView numberOfRowsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (UITableViewCell * _Nonnull)tableView:(UITableView * _Nonnull)tableView cellForRowAtIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (void)tableView:(UITableView * _Nonnull)tableView willDisplayCell:(UITableViewCell * _Nonnull)cell forRowAtIndexPath:(NSIndexPath * _Nonnull)indexPath;
/// :nodoc:
- (CGFloat)tableView:(UITableView * _Nonnull)tableView heightForFooterInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (UIView * _Nullable)tableView:(UITableView * _Nonnull)tableView viewForFooterInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (UIView * _Nullable)tableView:(UITableView * _Nonnull)tableView viewForHeaderInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
@end


/// An enum representing the status of a shipping address validation.
typedef SWIFT_ENUM(NSInteger, STPShippingStatus, open) {
/// The shipping address is valid.
  STPShippingStatusValid = 0,
/// The shipping address is invalid.
  STPShippingStatusInvalid = 1,
};

/// These values control the labels used in the shipping info collection form.
typedef SWIFT_ENUM(NSInteger, STPShippingType, open) {
/// Shipping the purchase to the provided address using a third-party
/// shipping company.
  STPShippingTypeShipping = 0,
/// Delivering the purchase by the seller.
  STPShippingTypeDelivery = 1,
};


@interface STPSource (SWIFT_EXTENSION(Stripe)) <STPPaymentOption>
@property (nonatomic, readonly, strong) UIImage * _Nonnull image;
@property (nonatomic, readonly, strong) UIImage * _Nonnull templateImage;
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
@property (nonatomic, readonly) BOOL isReusable;
@end

@class UIFont;

/// STPTheme objects can be used to visually style Stripe-provided UI. See https://stripe.com/docs/mobile/ios/basic#theming for more information.
SWIFT_CLASS("_TtC6Stripe8STPTheme")
@interface STPTheme : NSObject
/// The default theme used by all Stripe UI. All themable UI classes, such as <code>STPAddCardViewController</code>, have one initializer that takes a <code>theme</code> and one that does not. If you use the one that does not, the default theme will be used to customize that view controller’s appearance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) STPTheme * _Nonnull defaultTheme;)
+ (STPTheme * _Nonnull)defaultTheme SWIFT_WARN_UNUSED_RESULT;
/// The primary background color of the theme. This will be used as the <code>backgroundColor</code> for any views with this theme.
@property (nonatomic, strong) UIColor * _Nonnull primaryBackgroundColor;
/// The secondary background color of this theme. This will be used as the <code>backgroundColor</code> for any supplemental views inside a view with this theme - for example, a <code>UITableView</code> will set it’s cells’ background color to this value.
@property (nonatomic, strong) UIColor * _Nonnull secondaryBackgroundColor;
/// This color is automatically derived by reducing the alpha of the <code>primaryBackgroundColor</code> and is used as a section border color in table view cells.
@property (nonatomic, readonly, strong) UIColor * _Nonnull tertiaryBackgroundColor;
/// This color is automatically derived by reducing the brightness of the <code>primaryBackgroundColor</code> and is used as a separator color in table view cells.
@property (nonatomic, readonly, strong) UIColor * _Nonnull quaternaryBackgroundColor;
/// The primary foreground color of this theme. This will be used as the text color for any important labels in a view with this theme (such as the text color for a text field that the user needs to fill out).
@property (nonatomic, strong) UIColor * _Nonnull primaryForegroundColor;
/// The secondary foreground color of this theme. This will be used as the text color for any supplementary labels in a view with this theme (such as the placeholder color for a text field that the user needs to fill out).
@property (nonatomic, strong) UIColor * _Nonnull secondaryForegroundColor;
/// This color is automatically derived from the <code>secondaryForegroundColor</code> with a lower alpha component, used for disabled text.
@property (nonatomic, readonly, strong) UIColor * _Nonnull tertiaryForegroundColor;
/// The accent color of this theme - it will be used for any buttons and other elements on a view that are important to highlight.
@property (nonatomic, strong) UIColor * _Nonnull accentColor;
/// The error color of this theme - it will be used for rendering any error messages or views.
@property (nonatomic, strong) UIColor * _Nonnull errorColor;
/// The font to be used for all views using this theme. Make sure to select an appropriate size.
@property (nonatomic, strong) UIFont * _Nonnull font;
/// The medium-weight font to be used for all bold text in views using this theme. Make sure to select an appropriate size.
@property (nonatomic, strong) UIFont * _Nonnull emphasisFont;
/// The navigation bar style to use for any view controllers presented modally
/// by the SDK. The default value will be determined based on the brightness
/// of the theme’s <code>secondaryBackgroundColor</code>.
@property (nonatomic) UIBarStyle barStyle;
/// A Boolean value indicating whether the navigation bar for any view controllers
/// presented modally by the SDK should be translucent. The default value is YES.
@property (nonatomic) BOOL translucentNavigationBar;
/// This font is automatically derived from the font, with a slightly lower point size, and will be used for supplementary labels.
@property (nonatomic, readonly, strong) UIFont * _Nonnull smallFont;
/// This font is automatically derived from the font, with a larger point size, and will be used for large labels such as SMS code entry.
@property (nonatomic, readonly, strong) UIFont * _Nonnull largeFont;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


@interface STPTheme (SWIFT_EXTENSION(Stripe)) <NSCopying>
/// :nodoc:
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
@end

@class STPPaymentMethodBillingDetails;

/// You can use this class to specify information that you’ve already collected
/// from your user. You can then set the <code>prefilledInformation</code> property on
/// <code>STPPaymentContext</code>, <code>STPAddCardViewController</code>, etc and it will pre-fill
/// this information whenever possible.
SWIFT_CLASS("_TtC6Stripe18STPUserInformation")
@interface STPUserInformation : NSObject <NSCopying>
/// The user’s billing address. When set, the add card form will be filled with
/// this address. The user will also have the option to fill their shipping address
/// using this address.
/// @note Set this using <code>setBillingAddressWithBillingDetails:</code> to use the billing
/// details from an <code>STPPaymentMethod</code> or <code>STPPaymentMethodParams</code> instance.
@property (nonatomic, strong) STPAddress * _Nullable billingAddress;
/// The user’s shipping address. When set, the shipping address form will be filled
/// with this address. The user will also have the option to fill their billing
/// address using this address.
@property (nonatomic, strong) STPAddress * _Nullable shippingAddress;
/// A convenience method to populate <code>billingAddress</code> with a PaymentMethod’s billing details.
/// @note Calling this overwrites the value of <code>billingAddress</code>.
- (void)setBillingAddressWithBillingDetails:(STPPaymentMethodBillingDetails * _Nonnull)billingDetails;
/// :nodoc:
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end






@interface UINavigationBar (SWIFT_EXTENSION(Stripe))
/// Sets the navigation bar’s appearance to the desired theme. This will affect the
/// bar’s <code>tintColor</code> and <code>barTintColor</code> properties, as well as the color of the
/// single-pixel line at the bottom of the navbar.
/// \param theme the theme to use to style the navigation bar. - seealso: STPTheme.h
/// @deprecated Use the <code>stp_theme</code> property instead
///
- (void)stp_setTheme:(STPTheme * _Nonnull)theme SWIFT_DEPRECATED_MSG("Use the `stp_theme` property instead");
/// Sets the navigation bar’s appearance to the desired theme. This will affect the bar’s <code>tintColor</code> and <code>barTintColor</code> properties, as well as the color of the single-pixel line at the bottom of the navbar.
/// Stripe view controllers will use their navigation bar’s theme for their UIBarButtonItems instead of their own theme if it is not nil.
/// seealso:
/// STPTheme.h
@property (nonatomic, strong) STPTheme * _Nullable stp_theme;
@end











#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
